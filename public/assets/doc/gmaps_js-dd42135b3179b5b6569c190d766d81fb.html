<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>gmaps.js - RDoc Documentation</title>

<link href="./fonts.css" rel="stylesheet">
<link href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/navigation.js"></script>
<script src="./js/search_index.js"></script>
<script src="./js/search.js"></script>
<script src="./js/searcher.js"></script>
<script src="./js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./api_js_coffee.html">api.js.coffee</a>
  
    <li><a href="./application_js.html">application.js</a>
  
    <li><a href="./backbone/cs210_stockholm_js_coffee.html">cs210_stockholm.js.coffee</a>
  
    <li><a href="./bootstrap-tagsinput_js.html">bootstrap-tagsinput.js</a>
  
    <li><a href="./collections_js_coffee.html">collections.js.coffee</a>
  
    <li><a href="./create_js_coffee.html">create.js.coffee</a>
  
    <li><a href="./d3_min_js.html">d3.min.js</a>
  
    <li><a href="./dashboard_js_coffee.html">dashboard.js.coffee</a>
  
    <li><a href="./dataset_js_coffee.html">dataset.js.coffee</a>
  
    <li><a href="./draggabilly_pkgd_js.html">draggabilly.pkgd.js</a>
  
    <li><a href="./entries_js_coffee.html">entries.js.coffee</a>
  
    <li><a href="./gmaps_js.html">gmaps.js</a>
  
    <li><a href="./graph_js_coffee.html">graph.js.coffee</a>
  
    <li><a href="./jquery_form_min_js.html">jquery.form.min.js</a>
  
    <li><a href="./nv_d3_js.html">nv.d3.js</a>
  
    <li><a href="./packery_pkgd_min_js.html">packery.pkgd.min.js</a>
  
    <li><a href="./parser_js_coffee.html">parser.js.coffee</a>
  
    <li><a href="./properties_js_coffee.html">properties.js.coffee</a>
  
    <li><a href="./spin_min_js.html">spin.min.js</a>
  
    <li><a href="./tag-it_min_js.html">tag-it.min.js</a>
  
    <li><a href="./typeahead_js.html">typeahead.js</a>
  
    <li><a href="./users_js_coffee.html">users.js.coffee</a>
  
    <li><a href="./visualization_js_coffee.html">visualization.js.coffee</a>
  
    <li><a href="./welcome_js_coffee.html">welcome.js.coffee</a>
  
    <li><a href="./worksheet_js_coffee.html">worksheet.js.coffee</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page gmaps.js">

<p>(function(root, factory) {</p>

<pre>if(typeof exports === &#39;object&#39;) {
  module.exports = factory();
}
else if(typeof define === &#39;function&#39; &amp;&amp; define.amd) {
  define(&#39;GMaps&#39;, [], factory);
}

root.GMaps = factory();</pre>

<p>}(this, function() {</p>

<pre>!
 GMaps.js v0.4.11
 http://hpneo.github.com/gmaps/

 Copyright 2014, Gustavo Leon
 Released under the MIT License.</pre>

<p>if (!(typeof window.google === &#39;object&#39; &amp;&amp;
window.google.maps)) {</p>

<pre>throw &#39;Google Maps API is required. Please register the following JavaScript library http://maps.google.com/maps/api/js?sensor=true.&#39;</pre>

<p>}</p>

<p>var extend_object = function(obj, new_obj) {</p>

<pre>var name;

if (obj === new_obj) {
  return obj;
}

for (name in new_obj) {
  obj[name] = new_obj[name];
}

return obj;</pre>

<p>};</p>

<p>var replace_object = function(obj, replace) {</p>

<pre>var name;

if (obj === replace) {
  return obj;
}

for (name in replace) {
  if (obj[name] != undefined) {
    obj[name] = replace[name];
  }
}

return obj;</pre>

<p>};</p>

<p>var array_map = function(array, callback) {</p>

<pre>var original_callback_params = Array.prototype.slice.call(arguments, 2),
    array_return = [],
    array_length = array.length,
    i;

if (Array.prototype.map &amp;&amp; array.map === Array.prototype.map) {
  array_return = Array.prototype.map.call(array, function(item) {
    callback_params = original_callback_params;
    callback_params.splice(0, 0, item);

    return callback.apply(this, callback_params);
  });
}
else {
  for (i = 0; i &lt; array_length; i++) {
    callback_params = original_callback_params;
    callback_params.splice(0, 0, array[i]);
    array_return.push(callback.apply(this, callback_params));
  }
}

return array_return;</pre>

<p>};</p>

<p>var array_flat = function(array) {</p>

<pre>var new_array = [],
    i;

for (i = 0; i &lt; array.length; i++) {
  new_array = new_array.concat(array[i]);
}

return new_array;</pre>

<p>};</p>

<p>var coordsToLatLngs = function(coords, useGeoJSON) {</p>

<pre>var first_coord = coords[0],
    second_coord = coords[1];

if (useGeoJSON) {
  first_coord = coords[1];
  second_coord = coords[0];
}

return new google.maps.LatLng(first_coord, second_coord);</pre>

<p>};</p>

<p>var arrayToLatLng = function(coords, useGeoJSON) {</p>

<pre>var i;

for (i = 0; i &lt; coords.length; i++) {
  if (coords[i].length &gt; 0 &amp;&amp; typeof(coords[i][0]) == &quot;object&quot;) {
    coords[i] = arrayToLatLng(coords[i], useGeoJSON);
  }
  else {
    coords[i] = coordsToLatLngs(coords[i], useGeoJSON);
  }
}

return coords;</pre>

<p>};</p>

<p>var getElementById = function(id, context) {</p>

<pre>var element,
id = id.replace(&#39;#&#39;, &#39;&#39;);

if (&#39;jQuery&#39; in this &amp;&amp; context) {
  element = $(&quot;#&quot; + id, context)[0];
} else {
  element = document.getElementById(id);
};

return element;</pre>

<p>};</p>

<p>var findAbsolutePosition = function(obj)  {</p>

<pre>var curleft = 0,
    curtop = 0;

if (obj.offsetParent) {
  do {
    curleft += obj.offsetLeft;
    curtop += obj.offsetTop;
  } while (obj = obj.offsetParent);
}

return [curleft, curtop];</pre>

<p>};</p>

<p>var GMaps = (function(global) {</p>

<pre>&quot;use strict&quot;;

var doc = document;

var GMaps = function(options) {
  if (!this) return new GMaps(options);

  options.zoom = options.zoom || 15;
  options.mapType = options.mapType || &#39;roadmap&#39;;

  var self = this,
      i,
      events_that_hide_context_menu = [&#39;bounds_changed&#39;, &#39;center_changed&#39;, &#39;click&#39;, &#39;dblclick&#39;, &#39;drag&#39;, &#39;dragend&#39;, &#39;dragstart&#39;, &#39;idle&#39;, &#39;maptypeid_changed&#39;, &#39;projection_changed&#39;, &#39;resize&#39;, &#39;tilesloaded&#39;, &#39;zoom_changed&#39;],
      events_that_doesnt_hide_context_menu = [&#39;mousemove&#39;, &#39;mouseout&#39;, &#39;mouseover&#39;],
      options_to_be_deleted = [&#39;el&#39;, &#39;lat&#39;, &#39;lng&#39;, &#39;mapType&#39;, &#39;width&#39;, &#39;height&#39;, &#39;markerClusterer&#39;, &#39;enableNewStyle&#39;],
      container_id = options.el || options.div,
      markerClustererFunction = options.markerClusterer,
      mapType = google.maps.MapTypeId[options.mapType.toUpperCase()],
      map_center = new google.maps.LatLng(options.lat, options.lng),
      zoomControl = options.zoomControl || true,
      zoomControlOpt = options.zoomControlOpt || {
        style: &#39;DEFAULT&#39;,
        position: &#39;TOP_LEFT&#39;
      },
      zoomControlStyle = zoomControlOpt.style || &#39;DEFAULT&#39;,
      zoomControlPosition = zoomControlOpt.position || &#39;TOP_LEFT&#39;,
      panControl = options.panControl || true,
      mapTypeControl = options.mapTypeControl || true,
      scaleControl = options.scaleControl || true,
      streetViewControl = options.streetViewControl || true,
      overviewMapControl = overviewMapControl || true,
      map_options = {},
      map_base_options = {
        zoom: this.zoom,
        center: map_center,
        mapTypeId: mapType
      },
      map_controls_options = {
        panControl: panControl,
        zoomControl: zoomControl,
        zoomControlOptions: {
          style: google.maps.ZoomControlStyle[zoomControlStyle],
          position: google.maps.ControlPosition[zoomControlPosition]
        },
        mapTypeControl: mapTypeControl,
        scaleControl: scaleControl,
        streetViewControl: streetViewControl,
        overviewMapControl: overviewMapControl
      };

  if (typeof(options.el) === &#39;string&#39; || typeof(options.div) === &#39;string&#39;) {
    this.el = getElementById(container_id, options.context);
  } else {
    this.el = container_id;
  }

  if (typeof(this.el) === &#39;undefined&#39; || this.el === null) {
    throw &#39;No element defined.&#39;;
  }

  window.context_menu = window.context_menu || {};
  window.context_menu[self.el.id] = {};

  this.controls = [];
  this.overlays = [];
  this.layers = []; // array with kml/georss and fusiontables layers, can be as many
  this.singleLayers = {}; // object with the other layers, only one per layer
  this.markers = [];
  this.polylines = [];
  this.routes = [];
  this.polygons = [];
  this.infoWindow = null;
  this.overlay_el = null;
  this.zoom = options.zoom;
  this.registered_events = {};

  this.el.style.width = options.width || this.el.scrollWidth || this.el.offsetWidth;
  this.el.style.height = options.height || this.el.scrollHeight || this.el.offsetHeight;

  google.maps.visualRefresh = options.enableNewStyle;

  for (i = 0; i &lt; options_to_be_deleted.length; i++) {
    delete options[options_to_be_deleted[i]];
  }

  if(options.disableDefaultUI != true) {
    map_base_options = extend_object(map_base_options, map_controls_options);
  }

  map_options = extend_object(map_base_options, options);

  for (i = 0; i &lt; events_that_hide_context_menu.length; i++) {
    delete map_options[events_that_hide_context_menu[i]];
  }

  for (i = 0; i &lt; events_that_doesnt_hide_context_menu.length; i++) {
    delete map_options[events_that_doesnt_hide_context_menu[i]];
  }

  this.map = new google.maps.Map(this.el, map_options);

  if (markerClustererFunction) {
    this.markerClusterer = markerClustererFunction.apply(this, [this.map]);
  }

  var buildContextMenuHTML = function(control, e) {
    var html = &#39;&#39;,
        options = window.context_menu[self.el.id][control];

    for (var i in options){
      if (options.hasOwnProperty(i)) {
        var option = options[i];

        html += &#39;&lt;li&gt;&lt;a id=&quot;&#39; + control + &#39;_&#39; + i + &#39;&quot; href=&quot;#&quot;&gt;&#39; + option.title + &#39;&lt;/a&gt;&lt;/li&gt;&#39;;
      }
    }

    if (!getElementById(&#39;gmaps_context_menu&#39;)) return;

    var context_menu_element = getElementById(&#39;gmaps_context_menu&#39;);

    context_menu_element.innerHTML = html;

    var context_menu_items = context_menu_element.getElementsByTagName(&#39;a&#39;),
        context_menu_items_count = context_menu_items.length,
        i;

    for (i = 0; i &lt; context_menu_items_count; i++) {
      var context_menu_item = context_menu_items[i];

      var assign_menu_item_action = function(ev){
        ev.preventDefault();

        options[this.id.replace(control + &#39;_&#39;, &#39;&#39;)].action.apply(self, [e]);
        self.hideContextMenu();
      };

      google.maps.event.clearListeners(context_menu_item, &#39;click&#39;);
      google.maps.event.addDomListenerOnce(context_menu_item, &#39;click&#39;, assign_menu_item_action, false);
    }

    var position = findAbsolutePosition.apply(this, [self.el]),
        left = position[0] + e.pixel.x - 15,
        top = position[1] + e.pixel.y- 15;

    context_menu_element.style.left = left + &quot;px&quot;;
    context_menu_element.style.top = top + &quot;px&quot;;

    context_menu_element.style.display = &#39;block&#39;;
  };

  this.buildContextMenu = function(control, e) {
    if (control === &#39;marker&#39;) {
      e.pixel = {};

      var overlay = new google.maps.OverlayView();
      overlay.setMap(self.map);

      overlay.draw = function() {
        var projection = overlay.getProjection(),
            position = e.marker.getPosition();

        e.pixel = projection.fromLatLngToContainerPixel(position);

        buildContextMenuHTML(control, e);
      };
    }
    else {
      buildContextMenuHTML(control, e);
    }
  };

  this.setContextMenu = function(options) {
    window.context_menu[self.el.id][options.control] = {};

    var i,
        ul = doc.createElement(&#39;ul&#39;);

    for (i in options.options) {
      if (options.options.hasOwnProperty(i)) {
        var option = options.options[i];

        window.context_menu[self.el.id][options.control][option.name] = {
          title: option.title,
          action: option.action
        };
      }
    }

    ul.id = &#39;gmaps_context_menu&#39;;
    ul.style.display = &#39;none&#39;;
    ul.style.position = &#39;absolute&#39;;
    ul.style.minWidth = &#39;100px&#39;;
    ul.style.background = &#39;white&#39;;
    ul.style.listStyle = &#39;none&#39;;
    ul.style.padding = &#39;8px&#39;;
    ul.style.boxShadow = &#39;2px 2px 6px #ccc&#39;;

    doc.body.appendChild(ul);

    var context_menu_element = getElementById(&#39;gmaps_context_menu&#39;)

    google.maps.event.addDomListener(context_menu_element, &#39;mouseout&#39;, function(ev) {
      if (!ev.relatedTarget || !this.contains(ev.relatedTarget)) {
        window.setTimeout(function(){
          context_menu_element.style.display = &#39;none&#39;;
        }, 400);
      }
    }, false);
  };

  this.hideContextMenu = function() {
    var context_menu_element = getElementById(&#39;gmaps_context_menu&#39;);

    if (context_menu_element) {
      context_menu_element.style.display = &#39;none&#39;;
    }
  };

  var setupListener = function(object, name) {
    google.maps.event.addListener(object, name, function(e){
      if (e == undefined) {
        e = this;
      }

      options[name].apply(this, [e]);

      self.hideContextMenu();
    });
  };

  for (var ev = 0; ev &lt; events_that_hide_context_menu.length; ev++) {
    var name = events_that_hide_context_menu[ev];

    if (name in options) {
      setupListener(this.map, name);
    }
  }

  for (var ev = 0; ev &lt; events_that_doesnt_hide_context_menu.length; ev++) {
    var name = events_that_doesnt_hide_context_menu[ev];

    if (name in options) {
      setupListener(this.map, name);
    }
  }

  google.maps.event.addListener(this.map, &#39;rightclick&#39;, function(e) {
    if (options.rightclick) {
      options.rightclick.apply(this, [e]);
    }

    if(window.context_menu[self.el.id][&#39;map&#39;] != undefined) {
      self.buildContextMenu(&#39;map&#39;, e);
    }
  });

  this.refresh = function() {
    google.maps.event.trigger(this.map, &#39;resize&#39;);
  };

  this.fitZoom = function() {
    var latLngs = [],
        markers_length = this.markers.length,
        i;

    for (i = 0; i &lt; markers_length; i++) {
      if(typeof(this.markers[i].visible) === &#39;boolean&#39; &amp;&amp; this.markers[i].visible) {
        latLngs.push(this.markers[i].getPosition());
      }
    }

    this.fitLatLngBounds(latLngs);
  };

  this.fitLatLngBounds = function(latLngs) {
    var total = latLngs.length;
    var bounds = new google.maps.LatLngBounds();

    for(var i=0; i &lt; total; i++) {
      bounds.extend(latLngs[i]);
    }

    this.map.fitBounds(bounds);
  };

  this.setCenter = function(lat, lng, callback) {
    this.map.panTo(new google.maps.LatLng(lat, lng));

    if (callback) {
      callback();
    }
  };

  this.getElement = function() {
    return this.el;
  };

  this.zoomIn = function(value) {
    value = value || 1;

    this.zoom = this.map.getZoom() + value;
    this.map.setZoom(this.zoom);
  };

  this.zoomOut = function(value) {
    value = value || 1;

    this.zoom = this.map.getZoom() - value;
    this.map.setZoom(this.zoom);
  };

  var native_methods = [],
      method;

  for (method in this.map) {
    if (typeof(this.map[method]) == &#39;function&#39; &amp;&amp; !this[method]) {
      native_methods.push(method);
    }
  }

  for (i=0; i &lt; native_methods.length; i++) {
    (function(gmaps, scope, method_name) {
      gmaps[method_name] = function(){
        return scope[method_name].apply(scope, arguments);
      };
    })(this, this.map, native_methods[i]);
  }
};

return GMaps;</pre>

<p>})(this);</p>

<p>GMaps.prototype.createControl = function(options) {</p>

<pre>var control = document.createElement(&#39;div&#39;);

control.style.cursor = &#39;pointer&#39;;

if (options.disableDefaultStyles !== true) {
  control.style.fontFamily = &#39;Roboto, Arial, sans-serif&#39;;
  control.style.fontSize = &#39;11px&#39;;
  control.style.boxShadow = &#39;rgba(0, 0, 0, 0.298039) 0px 1px 4px -1px&#39;;
}

for (var option in options.style) {
  control.style[option] = options.style[option];
}

if (options.id) {
  control.id = options.id;
}

if (options.classes) {
  control.className = options.classes;
}

if (options.content) {
  control.innerHTML = options.content;
}

for (var ev in options.events) {
  (function(object, name) {
    google.maps.event.addDomListener(object, name, function(){
      options.events[name].apply(this, [this]);
    });
  })(control, ev);
}

control.index = 1;

return control;</pre>

<p>};</p>

<p>GMaps.prototype.addControl = function(options) {</p>

<pre>var position = google.maps.ControlPosition[options.position.toUpperCase()];

delete options.position;

var control = this.createControl(options);
this.controls.push(control);

this.map.controls[position].push(control);

return control;</pre>

<p>};</p>

<p>GMaps.prototype.createMarker = function(options) {</p>

<pre>if (options.lat == undefined &amp;&amp; options.lng == undefined &amp;&amp; options.position == undefined) {
  throw &#39;No latitude or longitude defined.&#39;;
}

var self = this,
    details = options.details,
    fences = options.fences,
    outside = options.outside,
    base_options = {
      position: new google.maps.LatLng(options.lat, options.lng),
      map: null
    },
    marker_options = extend_object(base_options, options);

delete marker_options.lat;
delete marker_options.lng;
delete marker_options.fences;
delete marker_options.outside;

var marker = new google.maps.Marker(marker_options);

marker.fences = fences;

if (options.infoWindow) {
  marker.infoWindow = new google.maps.InfoWindow(options.infoWindow);

  var info_window_events = [&#39;closeclick&#39;, &#39;content_changed&#39;, &#39;domready&#39;, &#39;position_changed&#39;, &#39;zindex_changed&#39;];

  for (var ev = 0; ev &lt; info_window_events.length; ev++) {
    (function(object, name) {
      if (options.infoWindow[name]) {
        google.maps.event.addListener(object, name, function(e){
          options.infoWindow[name].apply(this, [e]);
        });
      }
    })(marker.infoWindow, info_window_events[ev]);
  }
}

var marker_events = [&#39;animation_changed&#39;, &#39;clickable_changed&#39;, &#39;cursor_changed&#39;, &#39;draggable_changed&#39;, &#39;flat_changed&#39;, &#39;icon_changed&#39;, &#39;position_changed&#39;, &#39;shadow_changed&#39;, &#39;shape_changed&#39;, &#39;title_changed&#39;, &#39;visible_changed&#39;, &#39;zindex_changed&#39;];

var marker_events_with_mouse = [&#39;dblclick&#39;, &#39;drag&#39;, &#39;dragend&#39;, &#39;dragstart&#39;, &#39;mousedown&#39;, &#39;mouseout&#39;, &#39;mouseover&#39;, &#39;mouseup&#39;];

for (var ev = 0; ev &lt; marker_events.length; ev++) {
  (function(object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(){
        options[name].apply(this, [this]);
      });
    }
  })(marker, marker_events[ev]);
}

for (var ev = 0; ev &lt; marker_events_with_mouse.length; ev++) {
  (function(map, object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(me){
        if(!me.pixel){
          me.pixel = map.getProjection().fromLatLngToPoint(me.latLng)
        }

        options[name].apply(this, [me]);
      });
    }
  })(this.map, marker, marker_events_with_mouse[ev]);
}

google.maps.event.addListener(marker, &#39;click&#39;, function() {
  this.details = details;

  if (options.click) {
    options.click.apply(this, [this]);
  }

  if (marker.infoWindow) {
    self.hideInfoWindows();
    marker.infoWindow.open(self.map, marker);
  }
});

google.maps.event.addListener(marker, &#39;rightclick&#39;, function(e) {
  e.marker = this;

  if (options.rightclick) {
    options.rightclick.apply(this, [e]);
  }

  if (window.context_menu[self.el.id][&#39;marker&#39;] != undefined) {
    self.buildContextMenu(&#39;marker&#39;, e);
  }
});

if (marker.fences) {
  google.maps.event.addListener(marker, &#39;dragend&#39;, function() {
    self.checkMarkerGeofence(marker, function(m, f) {
      outside(m, f);
    });
  });
}

return marker;</pre>

<p>};</p>

<p>GMaps.prototype.addMarker = function(options) {</p>

<pre>var marker;
if(options.hasOwnProperty(&#39;gm_accessors_&#39;)) {
  // Native google.maps.Marker object
  marker = options;
}
else {
  if ((options.hasOwnProperty(&#39;lat&#39;) &amp;&amp; options.hasOwnProperty(&#39;lng&#39;)) || options.position) {
    marker = this.createMarker(options);
  }
  else {
    throw &#39;No latitude or longitude defined.&#39;;
  }
}

marker.setMap(this.map);

if(this.markerClusterer) {
  this.markerClusterer.addMarker(marker);
}

this.markers.push(marker);

GMaps.fire(&#39;marker_added&#39;, marker, this);

return marker;</pre>

<p>};</p>

<p>GMaps.prototype.addMarkers = function(array) {</p>

<pre>for (var i = 0, marker; marker=array[i]; i++) {
  this.addMarker(marker);
}

return this.markers;</pre>

<p>};</p>

<p>GMaps.prototype.hideInfoWindows = function() {</p>

<pre>for (var i = 0, marker; marker = this.markers[i]; i++){
  if (marker.infoWindow) {
    marker.infoWindow.close();
  }
}</pre>

<p>};</p>

<p>GMaps.prototype.removeMarker = function(marker) {</p>

<pre>for (var i = 0; i &lt; this.markers.length; i++) {
  if (this.markers[i] === marker) {
    this.markers[i].setMap(null);
    this.markers.splice(i, 1);

    if(this.markerClusterer) {
      this.markerClusterer.removeMarker(marker);
    }

    GMaps.fire(&#39;marker_removed&#39;, marker, this);

    break;
  }
}

return marker;</pre>

<p>};</p>

<p>GMaps.prototype.removeMarkers = function (collection) {</p>

<pre>var new_markers = [];

if (typeof collection == &#39;undefined&#39;) {
  for (var i = 0; i &lt; this.markers.length; i++) {
    this.markers[i].setMap(null);
  }

  this.markers = new_markers;
}
else {
  for (var i = 0; i &lt; collection.length; i++) {
    if (this.markers.indexOf(collection[i]) &gt; -1) {
      this.markers[i].setMap(null);
    }
  }

  for (var i = 0; i &lt; this.markers.length; i++) {
    if (this.markers[i].getMap() != null) {
      new_markers.push(this.markers[i]);
    }
  }

  this.markers = new_markers;
}</pre>

<p>};</p>

<p>GMaps.prototype.drawOverlay = function(options) {</p>

<pre>var overlay = new google.maps.OverlayView(),
    auto_show = true;

overlay.setMap(this.map);

if (options.auto_show != null) {
  auto_show = options.auto_show;
}

overlay.onAdd = function() {
  var el = document.createElement(&#39;div&#39;);

  el.style.borderStyle = &quot;none&quot;;
  el.style.borderWidth = &quot;0px&quot;;
  el.style.position = &quot;absolute&quot;;
  el.style.zIndex = 100;
  el.innerHTML = options.content;

  overlay.el = el;

  if (!options.layer) {
    options.layer = &#39;overlayLayer&#39;;
  }

  var panes = this.getPanes(),
      overlayLayer = panes[options.layer],
      stop_overlay_events = [&#39;contextmenu&#39;, &#39;DOMMouseScroll&#39;, &#39;dblclick&#39;, &#39;mousedown&#39;];

  overlayLayer.appendChild(el);

  for (var ev = 0; ev &lt; stop_overlay_events.length; ev++) {
    (function(object, name) {
      google.maps.event.addDomListener(object, name, function(e){
        if (navigator.userAgent.toLowerCase().indexOf(&#39;msie&#39;) != -1 &amp;&amp; document.all) {
          e.cancelBubble = true;
          e.returnValue = false;
        }
        else {
          e.stopPropagation();
        }
      });
    })(el, stop_overlay_events[ev]);
  }

  google.maps.event.trigger(this, &#39;ready&#39;);
};

overlay.draw = function() {
  var projection = this.getProjection(),
      pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng));

  options.horizontalOffset = options.horizontalOffset || 0;
  options.verticalOffset = options.verticalOffset || 0;

  var el = overlay.el,
      content = el.children[0],
      content_height = content.clientHeight,
      content_width = content.clientWidth;

  switch (options.verticalAlign) {
    case &#39;top&#39;:
      el.style.top = (pixel.y - content_height + options.verticalOffset) + &#39;px&#39;;
      break;
    default:
    case &#39;middle&#39;:
      el.style.top = (pixel.y - (content_height / 2) + options.verticalOffset) + &#39;px&#39;;
      break;
    case &#39;bottom&#39;:
      el.style.top = (pixel.y + options.verticalOffset) + &#39;px&#39;;
      break;
  }

  switch (options.horizontalAlign) {
    case &#39;left&#39;:
      el.style.left = (pixel.x - content_width + options.horizontalOffset) + &#39;px&#39;;
      break;
    default:
    case &#39;center&#39;:
      el.style.left = (pixel.x - (content_width / 2) + options.horizontalOffset) + &#39;px&#39;;
      break;
    case &#39;right&#39;:
      el.style.left = (pixel.x + options.horizontalOffset) + &#39;px&#39;;
      break;
  }

  el.style.display = auto_show ? &#39;block&#39; : &#39;none&#39;;

  if (!auto_show) {
    options.show.apply(this, [el]);
  }
};

overlay.onRemove = function() {
  var el = overlay.el;

  if (options.remove) {
    options.remove.apply(this, [el]);
  }
  else {
    overlay.el.parentNode.removeChild(overlay.el);
    overlay.el = null;
  }
};

this.overlays.push(overlay);
return overlay;</pre>

<p>};</p>

<p>GMaps.prototype.removeOverlay = function(overlay) {</p>

<pre>for (var i = 0; i &lt; this.overlays.length; i++) {
  if (this.overlays[i] === overlay) {
    this.overlays[i].setMap(null);
    this.overlays.splice(i, 1);

    break;
  }
}</pre>

<p>};</p>

<p>GMaps.prototype.removeOverlays = function() {</p>

<pre>for (var i = 0, item; item = this.overlays[i]; i++) {
  item.setMap(null);
}

this.overlays = [];</pre>

<p>};</p>

<p>GMaps.prototype.drawPolyline = function(options) {</p>

<pre>var path = [],
    points = options.path;

if (points.length) {
  if (points[0][0] === undefined) {
    path = points;
  }
  else {
    for (var i=0, latlng; latlng=points[i]; i++) {
      path.push(new google.maps.LatLng(latlng[0], latlng[1]));
    }
  }
}

var polyline_options = {
  map: this.map,
  path: path,
  strokeColor: options.strokeColor,
  strokeOpacity: options.strokeOpacity,
  strokeWeight: options.strokeWeight,
  geodesic: options.geodesic,
  clickable: true,
  editable: false,
  visible: true
};

if (options.hasOwnProperty(&quot;clickable&quot;)) {
  polyline_options.clickable = options.clickable;
}

if (options.hasOwnProperty(&quot;editable&quot;)) {
  polyline_options.editable = options.editable;
}

if (options.hasOwnProperty(&quot;icons&quot;)) {
  polyline_options.icons = options.icons;
}

if (options.hasOwnProperty(&quot;zIndex&quot;)) {
  polyline_options.zIndex = options.zIndex;
}

var polyline = new google.maps.Polyline(polyline_options);

var polyline_events = [&#39;click&#39;, &#39;dblclick&#39;, &#39;mousedown&#39;, &#39;mousemove&#39;, &#39;mouseout&#39;, &#39;mouseover&#39;, &#39;mouseup&#39;, &#39;rightclick&#39;];

for (var ev = 0; ev &lt; polyline_events.length; ev++) {
  (function(object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(e){
        options[name].apply(this, [e]);
      });
    }
  })(polyline, polyline_events[ev]);
}

this.polylines.push(polyline);

GMaps.fire(&#39;polyline_added&#39;, polyline, this);

return polyline;</pre>

<p>};</p>

<p>GMaps.prototype.removePolyline = function(polyline) {</p>

<pre>for (var i = 0; i &lt; this.polylines.length; i++) {
  if (this.polylines[i] === polyline) {
    this.polylines[i].setMap(null);
    this.polylines.splice(i, 1);

    GMaps.fire(&#39;polyline_removed&#39;, polyline, this);

    break;
  }
}</pre>

<p>};</p>

<p>GMaps.prototype.removePolylines = function() {</p>

<pre>for (var i = 0, item; item = this.polylines[i]; i++) {
  item.setMap(null);
}

this.polylines = [];</pre>

<p>};</p>

<p>GMaps.prototype.drawCircle = function(options) {</p>

<pre>options =  extend_object({
  map: this.map,
  center: new google.maps.LatLng(options.lat, options.lng)
}, options);

delete options.lat;
delete options.lng;

var polygon = new google.maps.Circle(options),
    polygon_events = [&#39;click&#39;, &#39;dblclick&#39;, &#39;mousedown&#39;, &#39;mousemove&#39;, &#39;mouseout&#39;, &#39;mouseover&#39;, &#39;mouseup&#39;, &#39;rightclick&#39;];

for (var ev = 0; ev &lt; polygon_events.length; ev++) {
  (function(object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(e){
        options[name].apply(this, [e]);
      });
    }
  })(polygon, polygon_events[ev]);
}

this.polygons.push(polygon);

return polygon;</pre>

<p>};</p>

<p>GMaps.prototype.drawRectangle = function(options) {</p>

<pre>options = extend_object({
  map: this.map
}, options);

var latLngBounds = new google.maps.LatLngBounds(
  new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]),
  new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1])
);

options.bounds = latLngBounds;

var polygon = new google.maps.Rectangle(options),
    polygon_events = [&#39;click&#39;, &#39;dblclick&#39;, &#39;mousedown&#39;, &#39;mousemove&#39;, &#39;mouseout&#39;, &#39;mouseover&#39;, &#39;mouseup&#39;, &#39;rightclick&#39;];

for (var ev = 0; ev &lt; polygon_events.length; ev++) {
  (function(object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(e){
        options[name].apply(this, [e]);
      });
    }
  })(polygon, polygon_events[ev]);
}

this.polygons.push(polygon);

return polygon;</pre>

<p>};</p>

<p>GMaps.prototype.drawPolygon = function(options) {</p>

<pre>var useGeoJSON = false;

if(options.hasOwnProperty(&quot;useGeoJSON&quot;)) {
  useGeoJSON = options.useGeoJSON;
}

delete options.useGeoJSON;

options = extend_object({
  map: this.map
}, options);

if (useGeoJSON == false) {
  options.paths = [options.paths.slice(0)];
}

if (options.paths.length &gt; 0) {
  if (options.paths[0].length &gt; 0) {
    options.paths = array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON));
  }
}

var polygon = new google.maps.Polygon(options),
    polygon_events = [&#39;click&#39;, &#39;dblclick&#39;, &#39;mousedown&#39;, &#39;mousemove&#39;, &#39;mouseout&#39;, &#39;mouseover&#39;, &#39;mouseup&#39;, &#39;rightclick&#39;];

for (var ev = 0; ev &lt; polygon_events.length; ev++) {
  (function(object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(e){
        options[name].apply(this, [e]);
      });
    }
  })(polygon, polygon_events[ev]);
}

this.polygons.push(polygon);

GMaps.fire(&#39;polygon_added&#39;, polygon, this);

return polygon;</pre>

<p>};</p>

<p>GMaps.prototype.removePolygon = function(polygon) {</p>

<pre>for (var i = 0; i &lt; this.polygons.length; i++) {
  if (this.polygons[i] === polygon) {
    this.polygons[i].setMap(null);
    this.polygons.splice(i, 1);

    GMaps.fire(&#39;polygon_removed&#39;, polygon, this);

    break;
  }
}</pre>

<p>};</p>

<p>GMaps.prototype.removePolygons = function() {</p>

<pre>for (var i = 0, item; item = this.polygons[i]; i++) {
  item.setMap(null);
}

this.polygons = [];</pre>

<p>};</p>

<p>GMaps.prototype.getFromFusionTables = function(options) {</p>

<pre>var events = options.events;

delete options.events;

var fusion_tables_options = options,
    layer = new google.maps.FusionTablesLayer(fusion_tables_options);

for (var ev in events) {
  (function(object, name) {
    google.maps.event.addListener(object, name, function(e) {
      events[name].apply(this, [e]);
    });
  })(layer, ev);
}

this.layers.push(layer);

return layer;</pre>

<p>};</p>

<p>GMaps.prototype.loadFromFusionTables = function(options) {</p>

<pre>var layer = this.getFromFusionTables(options);
layer.setMap(this.map);

return layer;</pre>

<p>};</p>

<p>GMaps.prototype.getFromKML = function(options) {</p>

<pre>var url = options.url,
    events = options.events;

delete options.url;
delete options.events;

var kml_options = options,
    layer = new google.maps.KmlLayer(url, kml_options);

for (var ev in events) {
  (function(object, name) {
    google.maps.event.addListener(object, name, function(e) {
      events[name].apply(this, [e]);
    });
  })(layer, ev);
}

this.layers.push(layer);

return layer;</pre>

<p>};</p>

<p>GMaps.prototype.loadFromKML = function(options) {</p>

<pre>var layer = this.getFromKML(options);
layer.setMap(this.map);

return layer;</pre>

<p>};</p>

<p>GMaps.prototype.addLayer = function(layerName, options) {</p>

<pre>//var default_layers = [&#39;weather&#39;, &#39;clouds&#39;, &#39;traffic&#39;, &#39;transit&#39;, &#39;bicycling&#39;, &#39;panoramio&#39;, &#39;places&#39;];
options = options || {};
var layer;

switch(layerName) {
  case &#39;weather&#39;: this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer();
    break;
  case &#39;clouds&#39;: this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer();
    break;
  case &#39;traffic&#39;: this.singleLayers.traffic = layer = new google.maps.TrafficLayer();
    break;
  case &#39;transit&#39;: this.singleLayers.transit = layer = new google.maps.TransitLayer();
    break;
  case &#39;bicycling&#39;: this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer();
    break;
  case &#39;panoramio&#39;:
      this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer();
      layer.setTag(options.filter);
      delete options.filter;

      //click event
      if (options.click) {
        google.maps.event.addListener(layer, &#39;click&#39;, function(event) {
          options.click(event);
          delete options.click;
        });
      }
    break;
    case &#39;places&#39;:
      this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);

      //search, nearbySearch, radarSearch callback, Both are the same
      if (options.search || options.nearbySearch || options.radarSearch) {
        var placeSearchRequest  = {
          bounds : options.bounds || null,
          keyword : options.keyword || null,
          location : options.location || null,
          name : options.name || null,
          radius : options.radius || null,
          rankBy : options.rankBy || null,
          types : options.types || null
        };

        if (options.radarSearch) {
          layer.radarSearch(placeSearchRequest, options.radarSearch);
        }

        if (options.search) {
          layer.search(placeSearchRequest, options.search);
        }

        if (options.nearbySearch) {
          layer.nearbySearch(placeSearchRequest, options.nearbySearch);
        }
      }

      //textSearch callback
      if (options.textSearch) {
        var textSearchRequest  = {
          bounds : options.bounds || null,
          location : options.location || null,
          query : options.query || null,
          radius : options.radius || null
        };

        layer.textSearch(textSearchRequest, options.textSearch);
      }
    break;
}

if (layer !== undefined) {
  if (typeof layer.setOptions == &#39;function&#39;) {
    layer.setOptions(options);
  }
  if (typeof layer.setMap == &#39;function&#39;) {
    layer.setMap(this.map);
  }

  return layer;
}</pre>

<p>};</p>

<p>GMaps.prototype.removeLayer = function(layer) {</p>

<pre>if (typeof(layer) == &quot;string&quot; &amp;&amp; this.singleLayers[layer] !== undefined) {
   this.singleLayers[layer].setMap(null);

   delete this.singleLayers[layer];
}
else {
  for (var i = 0; i &lt; this.layers.length; i++) {
    if (this.layers[i] === layer) {
      this.layers[i].setMap(null);
      this.layers.splice(i, 1);

      break;
    }
  }
}</pre>

<p>};</p>

<p>var travelMode, unitSystem;</p>

<p>GMaps.prototype.getRoutes = function(options) {</p>

<pre>switch (options.travelMode) {
  case &#39;bicycling&#39;:
    travelMode = google.maps.TravelMode.BICYCLING;
    break;
  case &#39;transit&#39;:
    travelMode = google.maps.TravelMode.TRANSIT;
    break;
  case &#39;driving&#39;:
    travelMode = google.maps.TravelMode.DRIVING;
    break;
  default:
    travelMode = google.maps.TravelMode.WALKING;
    break;
}

if (options.unitSystem === &#39;imperial&#39;) {
  unitSystem = google.maps.UnitSystem.IMPERIAL;
}
else {
  unitSystem = google.maps.UnitSystem.METRIC;
}

var base_options = {
      avoidHighways: false,
      avoidTolls: false,
      optimizeWaypoints: false,
      waypoints: []
    },
    request_options =  extend_object(base_options, options);

request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
request_options.destination = /string/.test(typeof options.destination) ? options.destination : new google.maps.LatLng(options.destination[0], options.destination[1]);
request_options.travelMode = travelMode;
request_options.unitSystem = unitSystem;

delete request_options.callback;
delete request_options.error;

var self = this,
    service = new google.maps.DirectionsService();

service.route(request_options, function(result, status) {
  if (status === google.maps.DirectionsStatus.OK) {
    for (var r in result.routes) {
      if (result.routes.hasOwnProperty(r)) {
        self.routes.push(result.routes[r]);
      }
    }

    if (options.callback) {
      options.callback(self.routes);
    }
  }
  else {
    if (options.error) {
      options.error(result, status);
    }
  }
});</pre>

<p>};</p>

<p>GMaps.prototype.removeRoutes = function() {</p>

<pre>this.routes = [];</pre>

<p>};</p>

<p>GMaps.prototype.getElevations = function(options) {</p>

<pre>options = extend_object({
  locations: [],
  path : false,
  samples : 256
}, options);

if (options.locations.length &gt; 0) {
  if (options.locations[0].length &gt; 0) {
    options.locations = array_flat(array_map([options.locations], arrayToLatLng,  false));
  }
}

var callback = options.callback;
delete options.callback;

var service = new google.maps.ElevationService();

//location request
if (!options.path) {
  delete options.path;
  delete options.samples;

  service.getElevationForLocations(options, function(result, status) {
    if (callback &amp;&amp; typeof(callback) === &quot;function&quot;) {
      callback(result, status);
    }
  });
//path request
} else {
  var pathRequest = {
    path : options.locations,
    samples : options.samples
  };

  service.getElevationAlongPath(pathRequest, function(result, status) {
   if (callback &amp;&amp; typeof(callback) === &quot;function&quot;) {
      callback(result, status);
    }
  });
}</pre>

<p>};</p>

<p>GMaps.prototype.cleanRoute = GMaps.prototype.removePolylines;</p>

<p>GMaps.prototype.drawRoute = function(options) {</p>

<pre>var self = this;

this.getRoutes({
  origin: options.origin,
  destination: options.destination,
  travelMode: options.travelMode,
  waypoints: options.waypoints,
  unitSystem: options.unitSystem,
  error: options.error,
  callback: function(e) {
    if (e.length &gt; 0) {
      self.drawPolyline({
        path: e[e.length - 1].overview_path,
        strokeColor: options.strokeColor,
        strokeOpacity: options.strokeOpacity,
        strokeWeight: options.strokeWeight
      });

      if (options.callback) {
        options.callback(e[e.length - 1]);
      }
    }
  }
});</pre>

<p>};</p>

<p>GMaps.prototype.travelRoute = function(options) {</p>

<pre>if (options.origin &amp;&amp; options.destination) {
  this.getRoutes({
    origin: options.origin,
    destination: options.destination,
    travelMode: options.travelMode,
    waypoints : options.waypoints,
    error: options.error,
    callback: function(e) {
      //start callback
      if (e.length &gt; 0 &amp;&amp; options.start) {
        options.start(e[e.length - 1]);
      }

      //step callback
      if (e.length &gt; 0 &amp;&amp; options.step) {
        var route = e[e.length - 1];
        if (route.legs.length &gt; 0) {
          var steps = route.legs[0].steps;
          for (var i=0, step; step=steps[i]; i++) {
            step.step_number = i;
            options.step(step, (route.legs[0].steps.length - 1));
          }
        }
      }

      //end callback
      if (e.length &gt; 0 &amp;&amp; options.end) {
         options.end(e[e.length - 1]);
      }
    }
  });
}
else if (options.route) {
  if (options.route.legs.length &gt; 0) {
    var steps = options.route.legs[0].steps;
    for (var i=0, step; step=steps[i]; i++) {
      step.step_number = i;
      options.step(step);
    }
  }
}</pre>

<p>};</p>

<p>GMaps.prototype.drawSteppedRoute = function(options) {</p>

<pre>var self = this;

if (options.origin &amp;&amp; options.destination) {
  this.getRoutes({
    origin: options.origin,
    destination: options.destination,
    travelMode: options.travelMode,
    waypoints : options.waypoints,
    error: options.error,
    callback: function(e) {
      //start callback
      if (e.length &gt; 0 &amp;&amp; options.start) {
        options.start(e[e.length - 1]);
      }

      //step callback
      if (e.length &gt; 0 &amp;&amp; options.step) {
        var route = e[e.length - 1];
        if (route.legs.length &gt; 0) {
          var steps = route.legs[0].steps;
          for (var i=0, step; step=steps[i]; i++) {
            step.step_number = i;
            self.drawPolyline({
              path: step.path,
              strokeColor: options.strokeColor,
              strokeOpacity: options.strokeOpacity,
              strokeWeight: options.strokeWeight
            });
            options.step(step, (route.legs[0].steps.length - 1));
          }
        }
      }

      //end callback
      if (e.length &gt; 0 &amp;&amp; options.end) {
         options.end(e[e.length - 1]);
      }
    }
  });
}
else if (options.route) {
  if (options.route.legs.length &gt; 0) {
    var steps = options.route.legs[0].steps;
    for (var i=0, step; step=steps[i]; i++) {
      step.step_number = i;
      self.drawPolyline({
        path: step.path,
        strokeColor: options.strokeColor,
        strokeOpacity: options.strokeOpacity,
        strokeWeight: options.strokeWeight
      });
      options.step(step);
    }
  }
}</pre>

<p>};</p>

<p>GMaps.Route = function(options) {</p>

<pre>this.origin = options.origin;
this.destination = options.destination;
this.waypoints = options.waypoints;

this.map = options.map;
this.route = options.route;
this.step_count = 0;
this.steps = this.route.legs[0].steps;
this.steps_length = this.steps.length;

this.polyline = this.map.drawPolyline({
  path: new google.maps.MVCArray(),
  strokeColor: options.strokeColor,
  strokeOpacity: options.strokeOpacity,
  strokeWeight: options.strokeWeight
}).getPath();</pre>

<p>};</p>

<p>GMaps.Route.prototype.getRoute = function(options) {</p>

<pre>var self = this;

this.map.getRoutes({
  origin : this.origin,
  destination : this.destination,
  travelMode : options.travelMode,
  waypoints : this.waypoints || [],
  error: options.error,
  callback : function() {
    self.route = e[0];

    if (options.callback) {
      options.callback.call(self);
    }
  }
});</pre>

<p>};</p>

<p>GMaps.Route.prototype.back = function() {</p>

<pre>if (this.step_count &gt; 0) {
  this.step_count--;
  var path = this.route.legs[0].steps[this.step_count].path;

  for (var p in path){
    if (path.hasOwnProperty(p)){
      this.polyline.pop();
    }
  }
}</pre>

<p>};</p>

<p>GMaps.Route.prototype.forward = function() {</p>

<pre>if (this.step_count &lt; this.steps_length) {
  var path = this.route.legs[0].steps[this.step_count].path;

  for (var p in path){
    if (path.hasOwnProperty(p)){
      this.polyline.push(path[p]);
    }
  }
  this.step_count++;
}</pre>

<p>};</p>

<p>GMaps.prototype.checkGeofence = function(lat, lng, fence) {</p>

<pre>return fence.containsLatLng(new google.maps.LatLng(lat, lng));</pre>

<p>};</p>

<p>GMaps.prototype.checkMarkerGeofence = function(marker, outside_callback) {</p>

<pre>if (marker.fences) {
  for (var i = 0, fence; fence = marker.fences[i]; i++) {
    var pos = marker.getPosition();
    if (!this.checkGeofence(pos.lat(), pos.lng(), fence)) {
      outside_callback(marker, fence);
    }
  }
}</pre>

<p>};</p>

<p>GMaps.prototype.toImage = function(options) {</p>

<pre>var options = options || {},
    static_map_options = {};

static_map_options[&#39;size&#39;] = options[&#39;size&#39;] || [this.el.clientWidth, this.el.clientHeight];
static_map_options[&#39;lat&#39;] = this.getCenter().lat();
static_map_options[&#39;lng&#39;] = this.getCenter().lng();

if (this.markers.length &gt; 0) {
  static_map_options[&#39;markers&#39;] = [];

  for (var i = 0; i &lt; this.markers.length; i++) {
    static_map_options[&#39;markers&#39;].push({
      lat: this.markers[i].getPosition().lat(),
      lng: this.markers[i].getPosition().lng()
    });
  }
}

if (this.polylines.length &gt; 0) {
  var polyline = this.polylines[0];

  static_map_options[&#39;polyline&#39;] = {};
  static_map_options[&#39;polyline&#39;][&#39;path&#39;] = google.maps.geometry.encoding.encodePath(polyline.getPath());
  static_map_options[&#39;polyline&#39;][&#39;strokeColor&#39;] = polyline.strokeColor
  static_map_options[&#39;polyline&#39;][&#39;strokeOpacity&#39;] = polyline.strokeOpacity
  static_map_options[&#39;polyline&#39;][&#39;strokeWeight&#39;] = polyline.strokeWeight
}

return GMaps.staticMapURL(static_map_options);</pre>

<p>};</p>

<p>GMaps.staticMapURL = function(options){</p>

<pre>var parameters = [],
    data,
    static_root = &#39;http://maps.googleapis.com/maps/api/staticmap&#39;;

if (options.url) {
  static_root = options.url;
  delete options.url;
}

static_root += &#39;?&#39;;

var markers = options.markers;

delete options.markers;

if (!markers &amp;&amp; options.marker) {
  markers = [options.marker];
  delete options.marker;
}

var styles = options.styles;

delete options.styles;

var polyline = options.polyline;
delete options.polyline;

    Map options    
if (options.center) {
  parameters.push(&#39;center=&#39; + options.center);
  delete options.center;
}
else if (options.address) {
  parameters.push(&#39;center=&#39; + options.address);
  delete options.address;
}
else if (options.lat) {
  parameters.push([&#39;center=&#39;, options.lat, &#39;,&#39;, options.lng].join(&#39;&#39;));
  delete options.lat;
  delete options.lng;
}
else if (options.visible) {
  var visible = encodeURI(options.visible.join(&#39;|&#39;));
  parameters.push(&#39;visible=&#39; + visible);
}

var size = options.size;
if (size) {
  if (size.join) {
    size = size.join(&#39;x&#39;);
  }
  delete options.size;
}
else {
  size = &#39;630x300&#39;;
}
parameters.push(&#39;size=&#39; + size);

if (!options.zoom &amp;&amp; options.zoom !== false) {
  options.zoom = 15;
}

var sensor = options.hasOwnProperty(&#39;sensor&#39;) ? !!options.sensor : true;
delete options.sensor;
parameters.push(&#39;sensor=&#39; + sensor);

for (var param in options) {
  if (options.hasOwnProperty(param)) {
    parameters.push(param + &#39;=&#39; + options[param]);
  }
}

/** Markers **/
if (markers) {
  var marker, loc;

  for (var i=0; data=markers[i]; i++) {
    marker = [];

    if (data.size &amp;&amp; data.size !== &#39;normal&#39;) {
      marker.push(&#39;size:&#39; + data.size);
      delete data.size;
    }
    else if (data.icon) {
      marker.push(&#39;icon:&#39; + encodeURI(data.icon));
      delete data.icon;
    }

    if (data.color) {
      marker.push(&#39;color:&#39; + data.color.replace(&#39;#&#39;, &#39;0x&#39;));
      delete data.color;
    }

    if (data.label) {
      marker.push(&#39;label:&#39; + data.label[0].toUpperCase());
      delete data.label;
    }

    loc = (data.address ? data.address : data.lat + &#39;,&#39; + data.lng);
    delete data.address;
    delete data.lat;
    delete data.lng;

    for(var param in data){
      if (data.hasOwnProperty(param)) {
        marker.push(param + &#39;:&#39; + data[param]);
      }
    }

    if (marker.length || i === 0) {
      marker.push(loc);
      marker = marker.join(&#39;|&#39;);
      parameters.push(&#39;markers=&#39; + encodeURI(marker));
    }
    // New marker without styles
    else {
      marker = parameters.pop() + encodeURI(&#39;|&#39; + loc);
      parameters.push(marker);
    }
  }
}

/** Map Styles **/
if (styles) {
  for (var i = 0; i &lt; styles.length; i++) {
    var styleRule = [];
    if (styles[i].featureType &amp;&amp; styles[i].featureType != &#39;all&#39; ) {
      styleRule.push(&#39;feature:&#39; + styles[i].featureType);
    }

    if (styles[i].elementType &amp;&amp; styles[i].elementType != &#39;all&#39;) {
      styleRule.push(&#39;element:&#39; + styles[i].elementType);
    }

    for (var j = 0; j &lt; styles[i].stylers.length; j++) {
      for (var p in styles[i].stylers[j]) {
        var ruleArg = styles[i].stylers[j][p];
        if (p == &#39;hue&#39; || p == &#39;color&#39;) {
          ruleArg = &#39;0x&#39; + ruleArg.substring(1);
        }
        styleRule.push(p + &#39;:&#39; + ruleArg);
      }
    }

    var rule = styleRule.join(&#39;|&#39;);
    if (rule != &#39;&#39;) {
      parameters.push(&#39;style=&#39; + rule);
    }
  }
}

/** Polylines **/
function parseColor(color, opacity) {
  if (color[0] === &#39;#&#39;){
    color = color.replace(&#39;#&#39;, &#39;0x&#39;);

    if (opacity) {
      opacity = parseFloat(opacity);
      opacity = Math.min(1, Math.max(opacity, 0));
      if (opacity === 0) {
        return &#39;0x00000000&#39;;
      }
      opacity = (opacity * 255).toString(16);
      if (opacity.length === 1) {
        opacity += opacity;
      }

      color = color.slice(0,8) + opacity;
    }
  }
  return color;
}

if (polyline) {
  data = polyline;
  polyline = [];

  if (data.strokeWeight) {
    polyline.push(&#39;weight:&#39; + parseInt(data.strokeWeight, 10));
  }

  if (data.strokeColor) {
    var color = parseColor(data.strokeColor, data.strokeOpacity);
    polyline.push(&#39;color:&#39; + color);
  }

  if (data.fillColor) {
    var fillcolor = parseColor(data.fillColor, data.fillOpacity);
    polyline.push(&#39;fillcolor:&#39; + fillcolor);
  }

  var path = data.path;
  if (path.join) {
    for (var j=0, pos; pos=path[j]; j++) {
      polyline.push(pos.join(&#39;,&#39;));
    }
  }
  else {
    polyline.push(&#39;enc:&#39; + path);
  }

  polyline = polyline.join(&#39;|&#39;);
  parameters.push(&#39;path=&#39; + encodeURI(polyline));
}

/** Retina support **/
var dpi = window.devicePixelRatio || 1;
parameters.push(&#39;scale=&#39; + dpi);

parameters = parameters.join(&#39;&amp;&#39;);
return static_root + parameters;</pre>

<p>};</p>

<p>GMaps.prototype.addMapType = function(mapTypeId, options) {</p>

<pre>if (options.hasOwnProperty(&quot;getTileUrl&quot;) &amp;&amp; typeof(options[&quot;getTileUrl&quot;]) == &quot;function&quot;) {
  options.tileSize = options.tileSize || new google.maps.Size(256, 256);

  var mapType = new google.maps.ImageMapType(options);

  this.map.mapTypes.set(mapTypeId, mapType);
}
else {
  throw &quot;&#39;getTileUrl&#39; function required.&quot;;
}</pre>

<p>};</p>

<p>GMaps.prototype.addOverlayMapType = function(options) {</p>

<pre>if (options.hasOwnProperty(&quot;getTile&quot;) &amp;&amp; typeof(options[&quot;getTile&quot;]) == &quot;function&quot;) {
  var overlayMapTypeIndex = options.index;

  delete options.index;

  this.map.overlayMapTypes.insertAt(overlayMapTypeIndex, options);
}
else {
  throw &quot;&#39;getTile&#39; function required.&quot;;
}</pre>

<p>};</p>

<p>GMaps.prototype.removeOverlayMapType = function(overlayMapTypeIndex) {</p>

<pre>this.map.overlayMapTypes.removeAt(overlayMapTypeIndex);</pre>

<p>};</p>

<p>GMaps.prototype.addStyle = function(options) {</p>

<pre>var styledMapType = new google.maps.StyledMapType(options.styles, { name: options.styledMapName });

this.map.mapTypes.set(options.mapTypeId, styledMapType);</pre>

<p>};</p>

<p>GMaps.prototype.setStyle = function(mapTypeId) {</p>

<pre>this.map.setMapTypeId(mapTypeId);</pre>

<p>};</p>

<p>GMaps.prototype.createPanorama = function(streetview_options) {</p>

<pre>if (!streetview_options.hasOwnProperty(&#39;lat&#39;) || !streetview_options.hasOwnProperty(&#39;lng&#39;)) {
  streetview_options.lat = this.getCenter().lat();
  streetview_options.lng = this.getCenter().lng();
}

this.panorama = GMaps.createPanorama(streetview_options);

this.map.setStreetView(this.panorama);

return this.panorama;</pre>

<p>};</p>

<p>GMaps.createPanorama = function(options) {</p>

<pre>var el = getElementById(options.el, options.context);

options.position = new google.maps.LatLng(options.lat, options.lng);

delete options.el;
delete options.context;
delete options.lat;
delete options.lng;

var streetview_events = [&#39;closeclick&#39;, &#39;links_changed&#39;, &#39;pano_changed&#39;, &#39;position_changed&#39;, &#39;pov_changed&#39;, &#39;resize&#39;, &#39;visible_changed&#39;],
    streetview_options = extend_object({visible : true}, options);

for (var i = 0; i &lt; streetview_events.length; i++) {
  delete streetview_options[streetview_events[i]];
}

var panorama = new google.maps.StreetViewPanorama(el, streetview_options);

for (var i = 0; i &lt; streetview_events.length; i++) {
  (function(object, name) {
    if (options[name]) {
      google.maps.event.addListener(object, name, function(){
        options[name].apply(this);
      });
    }
  })(panorama, streetview_events[i]);
}

return panorama;</pre>

<p>};</p>

<p>GMaps.prototype.on = function(event_name, handler) {</p>

<pre>return GMaps.on(event_name, this, handler);</pre>

<p>};</p>

<p>GMaps.prototype.off = function(event_name) {</p>

<pre>GMaps.off(event_name, this);</pre>

<p>};</p>

<p>GMaps.custom_events = [&#39;marker_added&#39;, &#39;marker_removed&#39;,
&#39;polyline_added&#39;, &#39;polyline_removed&#39;,
&#39;polygon_added&#39;, &#39;polygon_removed&#39;, &#39;geolocated&#39;,
&#39;geolocation_failed&#39;];</p>

<p>GMaps.on = function(event_name, object, handler) {</p>

<pre>if (GMaps.custom_events.indexOf(event_name) == -1) {
  return google.maps.event.addListener(object, event_name, handler);
}
else {
  var registered_event = {
    handler : handler,
    eventName : event_name
  };

  object.registered_events[event_name] = object.registered_events[event_name] || [];
  object.registered_events[event_name].push(registered_event);

  return registered_event;
}</pre>

<p>};</p>

<p>GMaps.off = function(event_name, object) {</p>

<pre>if (GMaps.custom_events.indexOf(event_name) == -1) {
  google.maps.event.clearListeners(object, event_name);
}
else {
  object.registered_events[event_name] = [];
}</pre>

<p>};</p>

<p>GMaps.fire = function(event_name, object, scope) {</p>

<pre>if (GMaps.custom_events.indexOf(event_name) == -1) {
  google.maps.event.trigger(object, event_name, Array.prototype.slice.apply(arguments).slice(2));
}
else {
  if(event_name in scope.registered_events) {
    var firing_events = scope.registered_events[event_name];

    for(var i = 0; i &lt; firing_events.length; i++) {
      (function(handler, scope, object) {
        handler.apply(scope, [object]);
      })(firing_events[i][&#39;handler&#39;], scope, object);
    }
  }
}</pre>

<p>};</p>

<p>GMaps.geolocate = function(options) {</p>

<pre>var complete_callback = options.always || options.complete;

if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(function(position) {
    options.success(position);

    if (complete_callback) {
      complete_callback();
    }
  }, function(error) {
    options.error(error);

    if (complete_callback) {
      complete_callback();
    }
  }, options.options);
}
else {
  options.not_supported();

  if (complete_callback) {
    complete_callback();
  }
}</pre>

<p>};</p>

<p>GMaps.geocode = function(options) {</p>

<pre>this.geocoder = new google.maps.Geocoder();
var callback = options.callback;
if (options.hasOwnProperty(&#39;lat&#39;) &amp;&amp; options.hasOwnProperty(&#39;lng&#39;)) {
  options.latLng = new google.maps.LatLng(options.lat, options.lng);
}

delete options.lat;
delete options.lng;
delete options.callback;

this.geocoder.geocode(options, function(results, status) {
  callback(results, status);
});</pre>

<p>};</p>

<p>//========================== // Polygon containsLatLng // <a
href="https://github.com/tparkin/Google-Maps-Point-in-Polygon">github.com/tparkin/Google-Maps-Point-in-Polygon</a>
// Poygon getBounds extension - google-maps-extensions // <a
href="http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js">code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js</a>
if (!google.maps.Polygon.prototype.getBounds) {</p>

<pre>google.maps.Polygon.prototype.getBounds = function(latLng) {
  var bounds = new google.maps.LatLngBounds();
  var paths = this.getPaths();
  var path;

  for (var p = 0; p &lt; paths.getLength(); p++) {
    path = paths.getAt(p);
    for (var i = 0; i &lt; path.getLength(); i++) {
      bounds.extend(path.getAt(i));
    }
  }

  return bounds;
};</pre>

<p>}</p>

<p>if (!google.maps.Polygon.prototype.containsLatLng) {</p>

<pre>// Polygon containsLatLng - method to determine if a latLng is within a polygon
google.maps.Polygon.prototype.containsLatLng = function(latLng) {
  // Exclude points outside of bounds as there is no way they are in the poly
  var bounds = this.getBounds();

  if (bounds !== null &amp;&amp; !bounds.contains(latLng)) {
    return false;
  }

  // Raycast point in polygon method
  var inPoly = false;

  var numPaths = this.getPaths().getLength();
  for (var p = 0; p &lt; numPaths; p++) {
    var path = this.getPaths().getAt(p);
    var numPoints = path.getLength();
    var j = numPoints - 1;

    for (var i = 0; i &lt; numPoints; i++) {
      var vertex1 = path.getAt(i);
      var vertex2 = path.getAt(j);

      if (vertex1.lng() &lt; latLng.lng() &amp;&amp; vertex2.lng() &gt;= latLng.lng() || vertex2.lng() &lt; latLng.lng() &amp;&amp; vertex1.lng() &gt;= latLng.lng()) {
        if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) &lt; latLng.lat()) {
          inPoly = !inPoly;
        }
      }

      j = i;
    }
  }

  return inPoly;
};</pre>

<p>}</p>

<p>google.maps.LatLngBounds.prototype.containsLatLng = function(latLng) {</p>

<pre>return this.contains(latLng);</pre>

<p>};</p>

<p>google.maps.Marker.prototype.setFences = function(fences) {</p>

<pre>this.fences = fences;</pre>

<p>};</p>

<p>google.maps.Marker.prototype.addFence = function(fence) {</p>

<pre>this.fences.push(fence);</pre>

<p>};</p>

<p>google.maps.Marker.prototype.getId = function() {</p>

<pre>return this[&#39;__gm_id&#39;];</pre>

<p>};</p>

<p>//========================== // Array indexOf // <a
href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf">developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf</a>
if (!Array.prototype.indexOf) {</p>

<pre>Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
    &quot;use strict&quot;;
    if (this == null) {
        throw new TypeError();
    }
    var t = Object(this);
    var len = t.length &gt;&gt;&gt; 0;
    if (len === 0) {
        return -1;
    }
    var n = 0;
    if (arguments.length &gt; 1) {
        n = Number(arguments[1]);
        if (n != n) { // shortcut for verifying if it&#39;s NaN
            n = 0;
        } else if (n != 0 &amp;&amp; n != Infinity &amp;&amp; n != -Infinity) {
            n = (n &gt; 0 || -1) * Math.floor(Math.abs(n));
        }
    }
    if (n &gt;= len) {
        return -1;
    }
    var k = n &gt;= 0 ? n : Math.max(len - Math.abs(n), 0);
    for (; k &lt; len; k++) {
        if (k in t &amp;&amp; t[k] === searchElement) {
            return k;
        }
    }
    return -1;
}</pre>

<p>}</p>

<p>return GMaps; }));</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

